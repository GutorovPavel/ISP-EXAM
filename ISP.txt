1. Базовые типы данных Python:

В Python есть несколько стандартных типов данных:
    • Numbers (числа)
    • Strings (строки)
    • Lists (списки)
    • Dictionaries (словари)
    • Tuples (кортежи)
    • Sets (множества)
    • Boolean (логический тип данных)
Эти типы данных можно, в свою очередь, классифицировать по нескольким признакам:
    • изменяемые (списки, словари и множества)
    • неизменяемые (числа, строки и кортежи)
    • упорядоченные (списки, кортежи, строки и словари)
    • неупорядоченные (множества)
    
Строка в Python это:
	последовательность символов, заключенная в кавычки
	неизменяемый упорядоченный тип данных

Список в Python это:
	последовательность элементов, разделенных между собой запятой и заключенных в квадратные скобки
	изменяемый упорядоченный тип данных

Словари - это изменяемый упорядоченный тип данных:
	данные в словаре - это пары ключ: значение
	доступ к значениям осуществляется по ключу, а не по номеру, как в списках
	данные в словаре упорядочены по порядку добавления элементов
	так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять
	ключ должен быть объектом неизменяемого типа: число, строка, кортеж
	значение может быть данными любого типа

Кортеж в Python это:
	последовательность элементов, которые разделены между собой запятой и заключены в скобки
	неизменяемый упорядоченный тип данных
	Грубо говоря, кортеж - это список, который нельзя изменить. То есть, в кортеже есть только права на чтение. Это может быть защитой от случайных изменений.
	Множество - это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы.
	Множество в Python - это последовательность элементов, которые разделены между собой запятой и заключены в фигурные скобки.


Булевые значения в Python это две константы True и False.


2. Операторы

Операторы Python бывают 7 типов:

	Арифметические операторы (Возведение в степень (**), Деление без остатка (//), Деление по модулю (остаток от деления) (%))
	Операторы сравнения
	Операторы присваивания
	Логические операторы (И (and), Или (or), Не (not))
	Операторы принадлежности (В (in), Нет в (not in))
	Операторы тождественности (Это (is), Это не (is not))
	Битовые операторы (Бинарное И (&), Бинарное ИЛИ (|), Бинарное ИЛИ НЕТ (^), Инвертирующий оператор (~), Бинарный сдвиг влево (<<), Бинарный сдвиг вправо (>>))
	
	
3. Функции

Функции — это объекты, поэтому их можно присваивать переменным.
Функции могут быть вложенными:

	def func1(a, b):

	    def inner_func(x):
		return x*x*x

	    return inner_func(a) + inner_func(b)
	    
При определении функции параметры со значениями по умолчанию нужно указывать до позиционных аргументов:

	def compute_surface(radius, pi=3.14159):
	    return pi * radius * radius
	    
Если использовать необязательный параметр, тогда все, что указаны справа, должны быть параметрами по умолчанию.
Выходит, что в следующем примере допущена ошибка:

	def compute_surface(radius=1, pi):
	    return pi * radius * radius
	   
 можно использовать словарь:

	params = {'a':10, 'b':20}
	S = f(**params)
		
Произвольное количество аргументов указывается через *args, значения записываются в КОРТЕЖ
аргументы-ключевые слова - **kwargs

	def print_mean_sequences(**kwargs):
	    def mean(data):
		return sum(data)/float(len(data))
	    for k, v in kwargs.items():
		print k, mean(v)
		
	print_mean_sequences(**{'x':[1,2,3], 'y':[3,3,0]}) #можно указать словарь, но с двумя звездочками
		ИЛИ
	print_mean_sequences(x=[1,2,3], y=[3,3,0])  -----  x 2.0 y 2.0


АНОНИМНАЯ ФУНКЦИЯ: ЛЯМБДА

Лямбда-функция — это короткая однострочная функция, которой даже не нужно имя давать. Такие выражения содержат лишь одну инструкцию, поэтому, например, if, for и while использовать нельзя. Их также можно присваивать переменным:

	product = lambda x,y: x*y

В отличие от функций, здесь не используется ключевое слово return. Результат работы и так возвращается.

С помощью type() можно проверить тип:

	>>> type(product)
	function

На практике эти функции редко используются. Это всего лишь элегантный способ записи, когда она содержит одну инструкцию.

	power = lambda x=1, y=2: x**y
	square = power
	square(5.)
	25
	power = lambda x,y,pow=2: x**pow + y
	[power(x,2, 3) for x in [0,1,2]]
	
	[2, 3, 10]
	
	
4. Элементы функционального программирования. Списковые выражения

Некоторые функции высшего порядка
	map() - преобразовать коллекцию 1 к 1 функцией (количество аргументов - количество переданных коллекций).
	reduce() - свёртка коллекции бинарной функцией.
	filter() - фильтрация коллекции с помощью унарной функции-предиката.
Сейчас в большинстве случаев вместо этих функций принято использовать list comprehensions.

	# map
	elems = range(1, 10)
	print elems
	print map(lambda value: 2**value, elems)
	[1, 2, 3, 4, 5, 6, 7, 8, 9]
	[2, 4, 8, 16, 32, 64, 128, 256, 512]
	
	# reduce
	elems = range(1, 10)
	print elems
	print reduce(lambda first, second: first + second, elems, -5)
	[1, 2, 3, 4, 5, 6, 7, 8, 9]
	40
	accum [1, 2, 3, 4, 5, 6, 7, 8, 9]
	accum = f(accum, 1)
	accum = f(accum, 2)
	a = f(accum, 3)

	accum = -5
	for elem in elems:
	    accum = accum + elem
	    
	# filter
	elems = range(1, 10)
	print elems
	print filter(lambda value: value % 2 == 0, elems)
	[1, 2, 3, 4, 5, 6, 7, 8, 9]
	[2, 4, 6, 8]
	
	
List comprehensions
Списковые включения (выражения) - pythonic способ построения списков с помощью выражений особого вида.
Осторожнее с читабельностью: иногда вместо сложного выражения лучше просто написать два обычных цикла
Код

	print [elem for elem in xrange(10)]
	print [elem for elem in xrange(10) if elem % 2 == 0]
	[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	[0, 2, 4, 6, 8]
	# may be too complex
	print [(elem, inner_elem)
		for elem in xrange(4)
		    for inner_elem in xrange(100, 104)
		        if elem % 2 != 0]
	[(1, 100), (1, 101), (1, 102), (1, 103), (3, 100), (3, 101), (3, 102), (3, 103)]
	# may be more readable version without list comprehension in such case
	elems = []
	for elem in xrange(4):
	    for inner_elem in xrange(100, 104):
		if elem % 2 != 0:
		    elems.append((elem, inner_elem))

	print elems
	[(1, 100), (1, 101), (1, 102), (1, 103), (3, 100), (3, 101), (3, 102), (3, 103)]
	# nested list comprehensions
	print [[(row, col) for col in xrange(3)] for row in xrange(4)]
	[[(0, 0), (0, 1), (0, 2)], [(1, 0), (1, 1), (1, 2)], [(2, 0), (2, 1), (2, 2)], [(3, 0), (3, 1), (3, 2)]]
	# list comprehensions and dict
	counters = {"a": 1, "c": 2, "f": 100500, "z": 3}
	print counters

	print [(key, value) for key, value in counters.iteritems()]
	{'a': 1, 'c': 2, 'z': 3, 'f': 100500}
	[('a', 1), ('c', 2), ('z', 3), ('f', 100500)]
	

